#!/usr/bin/env python3

"""
Extract the reference link definitions, and uses, from a .md file.

They are extracted *without normalisation* - in particular,
without case folding.  This is contrary to markdown semantics,
but it is desirable if we want to retain the original case.

When run as a program, prints a json document

{
   "used": ["anchor", ...],
   "defined"`: {"anchor": ["target", "title"] }
}

("title" can be null instead)
"""

# Basically all markdown parsers seem to treat undefined [foo]
# link references as literal text, including the [ ].
# I investigated several parsers including pandoc, marked (JS),
# and python3-markdown, and none of them seemed to have a way to
# override this or extract a list of apparently-unreferenced links.
#
# mistune has a hook mechanism, which we can abuse to insert
# instrumentation that spots when link definitions are queried,
# during processing.

import mistune  # type: ignore
import textwrap
from typing import Tuple


class Tracking:
    """
    Data structure which tracks used and defined keys.

    You may access the properties `used` and `defined`;
    `defined` mas each key to `(target, title)`.
    `used` is a map from keys to `True`,

    The keys here are *un*normalised, so they have not been lowercased.
    """

    defined: dict[str, Tuple[str, str]]
    used: dict[str, bool]

    def __init__(self):
        self.defined = {}
        self.used = {}

    def as_json(self):
        return json.dumps(
            {
                "used": list(self.used.keys()),
                "defined": self.defined,
            }
        )


class TrackingBlockParser(mistune.BlockParser):
    def __init__(self, track):
        self.track = track
        super().__init__()

    def parse_ref_link(self, m, state):
        # This relies on internal implementation details of mistune.
        # Expect this to break as the mistune version changes.
        # Last tested with mistune 3.1.3.

        key = m.group("reflink_1")
        href, href_pos = mistune.helpers.parse_link_href(state.src, m.end(), block=True)

        _blank = mistune.BlockParser.BLANK_LINE.search(state.src, href_pos)
        if _blank:
            max_pos = _blank.start()
        else:
            max_pos = state.cursor_max

        title, _ = mistune.helpers.parse_link_title(state.src, href_pos, max_pos)

        self.track.defined[key] = (href, title)
        return super().parse_ref_link(m, state)


class TrackingInlineParser(mistune.InlineParser):
    def __init__(self, track):
        self.track = track
        super().__init__()

    def parse_link(self, m, state):
        # Since we use `m.end()`, we won't find multi-line labels.
        # This is how mistune seems to handle it:
        # https://github.com/lepture/mistune/blob/4adac1c6e7e14e7deeb1bf6c6cd8c6816f537691/src/mistune/inline_parser.py#L127
        label, end_pos = mistune.helpers.parse_link_label(state.src, m.end())

        if label is None:
            print(
                "WARNING: skipping incorrectly formatted link:",
                state.src,
                file=sys.stderr,
            )
        else:
            # Here we unfortunately need to do some markdown parsing ourselves.
            # This is roughly what `InlineParser.parse_link()` does, but
            # unfortunately `InlineParser` throws the result away if a
            # corresponding link reference hasn't been defined[1], which
            # doesn't work for us since we want to find labels even when a link
            # reference hasn't been defined.
            #
            # [1]
            # https://github.com/lepture/mistune/blob/4adac1c6e7e14e7deeb1bf6c6cd8c6816f537691/src/mistune/inline_parser.py#L174-L175
            if end_pos is not None and end_pos < len(state.src):
                if state.src[end_pos] == "[":
                    # link with format [text][label]
                    label2, end_pos2 = mistune.helpers.parse_link_label(
                        state.src, end_pos + 1
                    )
                    if label2 is not None and end_pos2 is not None:
                        label = label2
                elif state.src[end_pos] == "(":
                    # link with format [text](url)
                    _, end_pos2 = mistune.helpers.parse_link(state.src, end_pos + 1)
                    if end_pos2 is not None:
                        label = None

            if label is not None:
                self.track.used[label] = True

        return super().parse_link(m, state)


def extract_links(md_string):
    """
    Given a markdown file, as a string, returns a `TrackingDict`
    containing information about its ref links.
    """

    track = Tracking()

    # Our construction is reaching into the mistune innards more than ideal.
    # It works with Debian's python3-mistune 3.1.3-1.
    md = mistune.Markdown(
        renderer=None,
        block=TrackingBlockParser(track),
        inline=TrackingInlineParser(track),
    )
    md(md_string)
    return track


def self_test():
    """
    A basic runtime test.
    """

    md = textwrap.dedent(
        """
        # Foo

        Test [link]. And [another]. What about [this][one]? Or [this](https://wikipedia.org)?

        [another]: https://example.com
        [not-present]: https://www.torproject.org
        """
    )

    extracted = extract_links(md)

    try:
        assert extracted.used == {"link": True, "another": True, "one": True}
        assert extracted.defined == {
            "another": ("https://example.com", None),
            "not-present": ("https://www.torproject.org", None),
        }
    except AssertionError as e:
        print("used:", extracted.used, file=sys.stderr)
        print("defined:", extracted.defined, file=sys.stderr)

        raise RuntimeError(
            "Failed self-test. "
            "This script appears to be incompatible with your version of mistune."
        ) from e


if __name__ == "__main__":
    # In theory we ought to be able to load file this as a Python module
    # instead of running it as a script.  But this does not work
    # because the Python module loading machinery insists that the filename
    # must end in .py.  But script names ought not to end in .py.
    #
    # The recipe here
    #    https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly
    # does not work with a filename not ending in .py:
    # "importlib.util.spec_from_file_location" returns None.

    import sys
    import json
    import argparse

    # Ensure that a basic self-test passes,
    # since we rely on some internal details of mistune.
    self_test()

    parser = argparse.ArgumentParser(prog="extract-md-links")
    parser.add_argument("filename", nargs="?", default="-")
    args = parser.parse_args()

    if args.filename == "-":
        in_file = sys.stdin
    else:
        in_file = open(args.filename, "r")

    text = in_file.read()
    print(extract_links(text).as_json())
